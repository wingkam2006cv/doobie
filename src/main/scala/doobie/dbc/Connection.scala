package doobie
package dbc

import scala.collection.JavaConverters._
import scalaz.effect._
import scalaz.effect.kleisliEffect._
import scalaz.syntax.effect.monadCatchIO._
import scalaz._
import Scalaz._
import java.sql
import java.sql.{ Savepoint, Blob, Clob, NClob, SQLXML, Struct }

trait ConnectionFunctions extends DWorld[java.sql.Connection] {

  def clearWarnings: Action[Unit] = 
    primitive(s"clearWarnings", _.clearWarnings)

  def close: Action[Unit] =
    primitive(s"close", _.close)

  def commit: Action[Unit] = 
    primitive(s"commit", _.commit)

  def createArrayOf(typeName: String, elements: Seq[AnyRef]): Action[sql.Array] =
    primitive(s"createArrayOf($typeName, $elements)", _.createArrayOf(typeName, elements.toArray))

  def createBlob: Action[Blob] = 
    primitive(s"createBlob", _.createBlob)

  def createClob: Action[Clob] = 
    primitive(s"createClob", _.createClob)

  def createNClob: Action[NClob] =
    primitive(s"createNClob", _.createNClob)

  def createSQLXML: Action[SQLXML] =
    primitive(s"createSQLXML", _.createSQLXML)

  // Helper for createStatement* methods below
  private def createStatement0[A](s: => String, f: sql.Connection => sql.Statement)(k: Statement[A]) = 
    gosub(primitive(s, f), k, statement.close)

  def createStatement[A]: Statement[A] => Action[A] = 
    createStatement0(s"createStatement", _.createStatement)

  def createStatement[A](rst: ResultSetType, rsc: ResultSetConcurrency): Statement[A] => Action[A] = 
    createStatement0(s"createStatement($rst, $rsc)", _.createStatement(rst.toInt, rsc.toInt))

  def createStatement[A](rst: ResultSetType, rsc: ResultSetConcurrency, rsh: Holdability): Statement[A] => Action[A] = 
    createStatement0(s"createStatement($rst, $rsc, $rsh)", _.createStatement(rst.toInt, rsc.toInt, rsh.toInt))

  def createStruct(typeName: String, attributes: Array[AnyRef]): Action[Struct] =
    primitive(s"createStruct($typeName, $attributes)", _.createStruct(typeName, attributes))

  def getAutoCommit: Action[Boolean] = 
    primitive(s"getAutoCommit", _.getAutoCommit)

  def getCatalog: Action[String] = 
    primitive(s"getCatalog", _.getCatalog)

  def getClientInfo: Action[Map[String, String]] =
    primitive(s"getClientInfo", _.getClientInfo.asScala.toMap)

  def getClientInfo(name: String): Action[String] =
    primitive(s"getClientInfo($name)", _.getClientInfo(name))

  def getHoldability: Action[Holdability] =
    primitive(s"getHoldability", _.getHoldability).map(Holdability.unsafeFromInt)

  def getMetaData[A](k: DatabaseMetaData[A]): Action[A] =
    gosub0(primitive(s"getMetaData", _.getMetaData), k)

  def getTransactionIsolation: Action[IsolationLevel] = 
    primitive(s"getTransactionIsolation", _.getTransactionIsolation).map(IsolationLevel.unsafeFromInt)

  def getTypeMap: Action[Map[String, Class[_]]] = 
    primitive(s"getTypeMap", _.getTypeMap.asScala.toMap)

  def getWarnings: Action[sql.SQLWarning] = 
    primitive(s"getWarnings", _.getWarnings)

  def isClosed: Action[Boolean] =
    primitive(s"isClosed", _.isClosed)

  def isReadOnly: Action[Boolean] = 
    primitive(s"isReadOnly", _.isReadOnly)

  def isValid(timeout: Int): Action[Boolean] =
    primitive(s"isValid($timeout)", _.isValid(timeout))

  def nativeSQL(sql: String): Action[String] =
    primitive(s"nativeSQL", _.nativeSQL(sql))

  // Helper for prepareCall* methods below
  private def prepareCall0[A](s: => String, f: sql.Connection => sql.CallableStatement)(k: CallableStatement[A]) = 
    gosub(primitive(s, f), k, callablestatement.close)

  def prepareCall[A](sql: String): CallableStatement[A] => Action[A] =
    prepareCall0(s"prepareCall($sql)", _.prepareCall(sql))

  def prepareCall[A](sql: String, rst: ResultSetType, rsc: ResultSetConcurrency): CallableStatement[A] => Action[A] =
    prepareCall0(s"prepareCall($sql, $rst, $rsc)", _.prepareCall(sql, rst.toInt, rsc.toInt))

  def prepareCall[A](sql: String, rst: ResultSetType, rsc: ResultSetConcurrency, rsh: Holdability): CallableStatement[A] => Action[A] =
    prepareCall0(s"prepareCall($sql, $rst, $rsc, $rsh)", _.prepareCall(sql, rst.toInt, rsc.toInt, rsh.toInt))

  // Helper for prepareStatement* methods below
  private def prepareStatement0[A](s: => String, f: sql.Connection => sql.PreparedStatement)(k: PreparedStatement[A]) = 
    gosub(primitive(s, f), k, preparedstatement.close)

  def prepareStatement[A](sql: String, autoGeneratedKeys: Int): PreparedStatement[A] => Action[A] =
    prepareStatement0(s"prepareStatement($sql, $autoGeneratedKeys)", _.prepareStatement(sql, autoGeneratedKeys))

  def prepareStatement[A](sql: String, columnIndexes: Seq[Int]): PreparedStatement[A] => Action[A] =
    prepareStatement0(s"prepareStatement($sql, $columnIndexes)", _.prepareStatement(sql, columnIndexes.toArray))

  def prepareStatement[A](sql: String): PreparedStatement[A] => Action[A] =
    prepareStatement0(s"prepareStatement($sql)", _.prepareStatement(sql))

  def prepareStatement[A](sql: String, rst: ResultSetType, rsc: ResultSetConcurrency): PreparedStatement[A] => Action[A] =
    prepareStatement0(s"prepareStatement($sql, $rst, $rsc)", _.prepareStatement(sql, rst.toInt, rsc.toInt))

  def prepareStatement[A](sql: String, rst: ResultSetType, rsc: ResultSetConcurrency, rsh: Holdability): PreparedStatement[A] => Action[A] =
    prepareStatement0(s"prepareStatement($sql, $rst, $rsc, $rsh)", _.prepareStatement(sql, rst.toInt, rsc.toInt, rsh.toInt))

  // Overloading fails due to erasure
  def prepareStatementA[A](sql: String, columnNames: Seq[String]): PreparedStatement[A] => Action[A] =
    prepareStatement0(s"prepareStatement($sql, $columnNames)", _.prepareStatement(sql, columnNames.toArray))

  def releaseSavepoint(savepoint: Savepoint): Action[Unit] =
    primitive(s"releaseSavepoint($savepoint)", _.releaseSavepoint(savepoint))

  def rollback: Action[Unit] = 
    primitive(s"rollback", _.rollback)

  def rollback(savepoint: Savepoint): Action[Unit] =
    primitive(s"rollback($savepoint)", _.rollback(savepoint))

  def setAutoCommit(autoCommit: Boolean): Action[Unit] =
    primitive(s"setAutoCommit($autoCommit)", _.setAutoCommit(autoCommit))

  def setCatalog(catalog: String): Action[Unit] =
    primitive(s"setCatalog($catalog)", _.setCatalog(catalog))

  def setClientInfo(properties: Map[String, String]): Action[Unit] =
    primitive(s"setClientInfo($properties)", _.setClientInfo(new java.util.Properties <| (_.putAll(properties.asJava))))

  def setClientInfo(name: String, value: String): Action[Unit] =
    primitive(s"setClientInfo($name, $value)", _.setClientInfo(name, value))

  def setHoldability(holdability: Holdability): Action[Unit] = 
    primitive(s"setHoldability($holdability)", _.setHoldability(holdability.toInt))

  def setReadOnly(readOnly: Boolean): Action[Unit] =
    primitive(s"setReadOnly($readOnly)", _.setReadOnly(readOnly))

  def setSavepoint: Action[Savepoint] =
    primitive(s"setSavepoint", _.setSavepoint)

  def setSavepoint(name: String): Action[Savepoint] =
    primitive(s"setSavepoint($name)", _.setSavepoint(name))

  def setTransactionIsolation(level: IsolationLevel): Action[Unit] =
    primitive(s"setTransactionIsolation($level)", _.setTransactionIsolation(level.toInt))

  def setTypeMap(map: Map[String, Class[_]]): Action[Unit] =
    primitive(s"setTypeMap($map)", _.setTypeMap(map.asJava))

}


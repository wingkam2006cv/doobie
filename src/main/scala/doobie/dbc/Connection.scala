package doobie
package dbc

import scala.collection.JavaConverters._
import scalaz.effect.IO
import scalaz.syntax.monad._
import scalaz.syntax.id._
import java.sql
import java.sql.{ Blob, Clob, NClob, SQLXML, Struct }

/** Module of actions in the context of a `java.sql.Connection`. */
object connection extends DWorld[java.sql.Connection] {

  type Connection[+A] = Action[A]

  private[dbc] def run[A](a: Connection[A], l: Log[LogElement], s: sql.Connection): IO[A] = 
    eval(a, l, s).map(_._2)

  ////// ACTIONS, IN ALPHABETIC ORDER

  def clearWarnings: Connection[Unit] = 
    effect(_.clearWarnings)

  def close: Connection[Unit] =
    effect("conn.close", _.close)

  def commit: Connection[Unit] = 
    effect(_.commit)

  def createArrayOf(typeName: String, elements: Seq[AnyRef]): Connection[sql.Array] =
    effect(_.createArrayOf(typeName, elements.toArray))

  def createBlob: Connection[Blob] = 
    effect(_.createBlob)

  def createClob: Connection[Clob] = 
    effect(_.createClob)

  def createNClob: Connection[NClob] =
    effect(_.createNClob)

  def createSQLXML: Connection[SQLXML] =
    effect(_.createSQLXML)

  // Helper for createStatement* methods below
  private def createStatement0[A](f: sql.Connection => sql.Statement)(k: Statement[A]) = {
    import dbc.{ statement => cs }
    for {
      l <- log
      s <- effect(f)
      a <- cs.run(k, l, s).ensuring(cs.run(cs.close, l, s)).liftIO[Connection]
    } yield a
  }

  def createStatement[A]: Statement[A] => Connection[A] = 
    createStatement0(_.createStatement)

  def createStatement[A](rst: ResultSetType, rsc: ResultSetConcurrency): Statement[A] => Connection[A] = 
    createStatement0(_.createStatement(rst.toInt, rsc.toInt))

  def createStatement[A](rst: ResultSetType, rsc: ResultSetConcurrency, rsh: Holdability): Statement[A] => Connection[A] = 
    createStatement0(_.createStatement(rst.toInt, rsc.toInt, rsh.toInt))

  def createStruct(typeName: String, attributes: Array[AnyRef]): Connection[Struct] =
    effect(_.createStruct(typeName, attributes))

  def getAutoCommit: Connection[Boolean] = 
    effect(_.getAutoCommit)

  def getCatalog: Connection[String] = 
    effect(_.getCatalog)

  def getClientInfo: Connection[Map[String, String]] =
    effect(_.getClientInfo.asScala.toMap)

  def getClientInfo(name: String): Connection[String] =
    effect(_.getClientInfo(name))

  def getHoldability: Connection[Holdability] =
    effect(_.getHoldability).map(Holdability.unsafeFromInt)

  def getMetaData[A](k: DatabaseMetaData[A]): Connection[A] =
    for {
      l <- log
      s <- effect(_.getMetaData)
      a <- databasemetadata.run(k, l, s).liftIO[Connection]
    } yield a

  def getTransactionIsolation: Connection[IsolationLevel] = 
    effect(_.getTransactionIsolation).map(IsolationLevel.unsafeFromInt)

  def getTypeMap: Connection[Map[String, Class[_]]] = 
    effect(_.getTypeMap.asScala.toMap)

  def getWarnings: Connection[sql.SQLWarning] = 
    effect(_.getWarnings)

  def isClosed: Connection[Boolean] =
    effect(_.isClosed)

  def isReadOnly: Connection[Boolean] = 
    effect(_.isReadOnly)

  def isValid(timeout: Int): Connection[Boolean] =
    effect(_.isValid(timeout))

  def nativeSQL(sql: String): Connection[String] =
    effect(_.nativeSQL(sql))

  // Helper for prepareCall* methods below
  private def prepareCall0[A](f: sql.Connection => sql.CallableStatement)(k: CallableStatement[A]) = {
    import dbc.{ callablestatement => cs }
    for {
      l <- log
      s <- effect(f)
      a <- cs.run(k, l, s).ensuring(cs.run(cs.close, l, s)).liftIO[Connection]
    } yield a
  }

  def prepareCall[A](sql: String): CallableStatement[A] => Connection[A] =
    prepareCall0(_.prepareCall(sql))

  def prepareCall[A](sql: String, rst: ResultSetType, rsc: ResultSetConcurrency): CallableStatement[A] => Connection[A] =
    prepareCall0(_.prepareCall(sql, rst.toInt, rsc.toInt))

  def prepareCall[A](sql: String, rst: ResultSetType, rsc: ResultSetConcurrency, rsh: Holdability): CallableStatement[A] => Connection[A] =
    prepareCall0(_.prepareCall(sql, rst.toInt, rsc.toInt, rsh.toInt))

  // Helper for prepareStatement* methods below
  private def prepareStatement0[A](s: String, f: sql.Connection => sql.PreparedStatement)(k: PreparedStatement[A]) = {
    import dbc.{ preparedstatement => ps }
    for {
      l <- log
      s <- effect(s, f)
      a <- push("executing preparedstatement action", ps.run(k, l, s).ensuring(ps.run(ps.close, l, s)).liftIO[Connection])
    } yield a
  }


  // def prepareStatement(sql: String, autoGeneratedKeys: Int): Connection[PreparedStatement] =
  //   ???

  // def prepareStatement[A](sql: String, columnIndexes: Seq[Int])(k: PreparedStatement[A]): Connection[A] =
  //    ???

  def prepareStatement[A](sql: String): PreparedStatement[A] => Connection[A] =
    prepareStatement0(s"prepareStatement($sql)", _.prepareStatement(sql))

  def prepareStatement[A](sql: String, rst: ResultSetType, rsc: ResultSetConcurrency): PreparedStatement[A] => Connection[A] =
    prepareStatement0(s"prepareStatement($sql, $rst, $rsc)", _.prepareStatement(sql, rst.toInt, rsc.toInt))

  def prepareStatement[A](sql: String, rst: ResultSetType, rsc: ResultSetConcurrency, rsh: Holdability): PreparedStatement[A] => Connection[A] =
    prepareStatement0(s"prepareStatement($sql, $rst, $rsc, $rsh)", _.prepareStatement(sql, rst.toInt, rsc.toInt, rsh.toInt))

  // def prepareStatement[A](sql: String, columnNames: Seq[String])(k: PreparedStatement[A]): Connection[A] =
  //    ???

  def releaseSavepoint(savepoint: Savepoint): Connection[Unit] =
    effect(_.releaseSavepoint(savepoint))

  def rollback: Connection[Unit] = 
    effect(_.rollback)

  def rollback(savepoint: Savepoint): Connection[Unit] =
    effect(_.rollback(savepoint))

  def setAutoCommit(autoCommit: Boolean): Connection[Unit] =
    effect(_.setAutoCommit(autoCommit))

  def setCatalog(catalog: String): Connection[Unit] =
    effect(_.setCatalog(catalog))

  def setClientInfo(properties: Map[String, String]): Connection[Unit] =
    effect(_.setClientInfo(new java.util.Properties <| (_.putAll(properties.asJava))))

  def setClientInfo(name: String, value: String): Connection[Unit] =
    effect(_.setClientInfo(name, value))

  def setHoldability(holdability: Holdability): Connection[Unit] = 
    effect(_.setHoldability(holdability.toInt))

  def setReadOnly(readOnly: Boolean): Connection[Unit] =
    effect(_.setReadOnly(readOnly))

  def setSavepoint: Connection[Savepoint] =
    effect(_.setSavepoint)

  def setSavepoint(name: String): Connection[Savepoint] =
    effect(_.setSavepoint(name))

  def setTransactionIsolation(level: IsolationLevel): Connection[Unit] =
    effect(_.setTransactionIsolation(level.toInt))

  def setTypeMap(map: Map[String, Class[_]]): Connection[Unit] =
    effect(_.setTypeMap(map.asJava))

}


package doobie
package dbc

import scalaz.effect.IO
import java.sql

object statement extends DWorld[sql.Statement] with StatementOps[sql.Statement] {

  type Statement[+A] = Action[A]

  private[dbc] def run[A](a: Action[A], l: Log[LogElement], s: sql.Statement): IO[A] = 
    eval(a, l, s).map(_._2)

}

trait StatementOps[A <: sql.Statement] { this: DWorld[A] => 
  
  def addBatch(sql: String): Action[Unit] =
    effect(_.addBatch(sql))

  def cancel: Action[Unit] =
    effect(_.cancel)

  def clearBatch: Action[Unit] =
    effect(_.clearBatch)

  def clearWarnings: Action[Unit] =
    effect(_.clearWarnings)

  def close: Action[Unit] =
    effect("ps.close", _.close)

  def execute(sql: String): Action[Boolean] =
    effect(_.execute(sql))

  // def execute(sql: String, autoGeneratedKeys: Int): Action[Boolean] =
  //   ???

  // def execute(sql: String, columnIndexes: Array[Int]): Action[Boolean] =
  //   ???

  // def execute(sql: String, columnNames: Array[String]): Action[Boolean] =
  //   ???

  def executeBatch: Action[List[Int]] =
    effect(_.executeBatch.toList)

  def executeQuery[A](sql: String)(k: ResultSet[A]): Action[A] =
    for {
      l <- log
      r <- effect(_.executeQuery(sql))
      a <- resultset.run(k, l, r).ensuring(resultset.run(resultset.close, l, r)).liftIO[Action]
    } yield a

  def executeUpdate(sql: String): Action[Int] =
    effect(_.executeUpdate(sql))

  // def executeUpdate(sql: String, autoGeneratedKeys: Int): Action[Int] =
  //   ???

  // def executeUpdate(sql: String, columnIndexes: Array[Int]): Action[Int] =
  //   ???

  // def executeUpdate(sql: String, columnNames: Array[String]): Action[Int] =
  //   ???

  def getConnection[A](k: Connection[A]): Action[A] =
    for {
      l <- log
      c <- effect(_.getConnection)
      a <- connection.run(k, l, c).liftIO[Action]
    } yield a

  def getFetchDirection: Action[FetchDirection] =
    effect(_.getFetchDirection).map(FetchDirection.unsafeFromInt)

  def getFetchSize: Action[Int] =
    effect(_.getFetchSize)

  def getGeneratedKeys(k: ResultSet[A]): Action[A] =
    for {
      l <- log
      r <- effect(_.getGeneratedKeys)
      a <- resultset.run(k, l, r).ensuring(resultset.run(resultset.close, l, r)).liftIO[Action]
    } yield a

  def getMaxFieldSize: Action[Int] =
    effect(_.getMaxFieldSize)

  def getMaxRows: Action[Int] =
    effect(_.getMaxRows)

  def getMoreResults: Action[Boolean] =
    effect(_.getMoreResults)

  def getMoreResults(current: Int): Action[Boolean] =
    effect(_.getMoreResults(current))

  def getQueryTimeout: Action[Int] =
    effect(_.getQueryTimeout)

  def getResultSet(k: ResultSet[A]): Action[A] =
    for {
      l <- log
      r <- effect(_.getResultSet)
      a <- resultset.run(k, l, r).ensuring(resultset.run(resultset.close, l, r)).liftIO[Action]
    } yield a

  def getResultSetConcurrency: Action[ResultSetConcurrency] =
    effect(_.getResultSetConcurrency).map(ResultSetConcurrency.unsafeFromInt)

  def getResultSetType: Action[ResultSetType] =
    effect(_.getResultSetType).map(ResultSetType.unsafeFromInt)

  def getUpdateCount: Action[Int] =
    effect(_.getUpdateCount)

  def getWarnings: Action[sql.SQLWarning] = 
    effect(_.getWarnings)

  def setCursorName(name: String): Action[Unit] =
    effect(_.setCursorName(name))

  def setEscapeProcessing(enable: Boolean): Action[Unit] =
    effect(_.setEscapeProcessing(enable))

  def setFetchDirection(direction: FetchDirection): Action[Unit] =
    effect(_.setFetchDirection(direction.toInt))

  def setFetchSize(rows: Int): Action[Unit] =
    effect(_.setFetchSize(rows))

  def setMaxFieldSize(max: Int): Action[Unit] =
    effect(_.setMaxFieldSize(max))

  def setMaxRows(max: Int): Action[Unit] =
    effect(_.setMaxRows(max))

  def setQueryTimeout(seconds: Int): Action[Unit] =
    effect(_.setQueryTimeout(seconds))

}

